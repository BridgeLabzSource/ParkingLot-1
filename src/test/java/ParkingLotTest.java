import com.bridgelabz.parkinglot.enums.DriverType;import com.bridgelabz.parkinglot.exception.ParkingLotException;import com.bridgelabz.parkinglot.model.VehicleDetails;import com.bridgelabz.parkinglot.observer.AirportSecurityImpl;import com.bridgelabz.parkinglot.observer.ParkingOwnerImpl;import com.bridgelabz.parkinglot.service.ParkingLot;import org.junit.Assert;import org.junit.Before;import org.junit.Test;import java.time.LocalDateTime;import java.time.format.DateTimeFormatter;public class ParkingLotTest {    ParkingLot parkingLot;    @Before    public void setUp() {        new Object();        parkingLot = new ParkingLot(100, 4);    }    @Test    public void givenAVehicle_IfParked_ShouldReturnTrue() throws ParkingLotException {        parkingLot.park(new VehicleDetails("MH-2222", DriverType.NON_HANDICAP_DRIVER));        boolean parkingStatus = ParkingLot.status;        Assert.assertTrue(parkingStatus);    }    @Test    public void givenAVehicle_IfUnParked_ShouldReturnTrue() throws ParkingLotException {        parkingLot.park(new VehicleDetails("MH-2222", DriverType.NON_HANDICAP_DRIVER));        parkingLot.park(new VehicleDetails("MH-1111", DriverType.NON_HANDICAP_DRIVER));        parkingLot.unPark("MH-2222");        boolean unParkingStatus = ParkingLot.status;        Assert.assertFalse(unParkingStatus);    }    @Test    public void givenAVehicle_IfNotPresentAndWantToUnParke_ShouldHandleException() {        try {            parkingLot.park(new VehicleDetails("MH-2222", DriverType.NON_HANDICAP_DRIVER));            parkingLot.unPark("MH-1111");        } catch (ParkingLotException e) {            Assert.assertEquals(ParkingLotException.ExceptionType.VEHICLE_NOT_PARKED, e.type);        }    }    @Test    public void givenVehicle_IfParkingLotIsFull_ShouldHandleException() {        try {            parkingLot.park(new VehicleDetails("MH-2222", DriverType.NON_HANDICAP_DRIVER));            parkingLot.park(new VehicleDetails("MH-1111", DriverType.NON_HANDICAP_DRIVER));            parkingLot.park(new VehicleDetails("MH-3333", DriverType.NON_HANDICAP_DRIVER));        } catch (ParkingLotException e) {            Assert.assertEquals(ParkingLotException.ExceptionType.PARKING_LOT_IS_FULL, e.type);        }    }    @Test    public void givenVehicle_IfParkingLotIsFullInformToOwner_ShouldHandleException() {        try {            parkingLot.park(new VehicleDetails("MH-2222", DriverType.NON_HANDICAP_DRIVER));            parkingLot.park(new VehicleDetails("MH-1111", DriverType.NON_HANDICAP_DRIVER));            parkingLot.park(new VehicleDetails("MH-3333", DriverType.NON_HANDICAP_DRIVER));        } catch (ParkingLotException e) {            Assert.assertTrue(ParkingOwnerImpl.status);            Assert.assertEquals(ParkingLotException.ExceptionType.PARKING_LOT_IS_FULL, e.type);        }    }    @Test    public void givenVehicle_IfAlreadyPresent_ShouldHandleException() {        try {            parkingLot.park(new VehicleDetails("MH-2222", DriverType.NON_HANDICAP_DRIVER));            parkingLot.park(new VehicleDetails("MH-2222", DriverType.NON_HANDICAP_DRIVER));        } catch (ParkingLotException e) {            Assert.assertEquals(ParkingLotException.ExceptionType.VEHICLE_ALREADY_PARKED, e.type);        }    }    @Test    public void givenVehicle_IfParkingLotIsFullInformToAirportSecurity_ShouldHandleException() {        try {            parkingLot.park(new VehicleDetails("MH-2222", DriverType.NON_HANDICAP_DRIVER));            parkingLot.park(new VehicleDetails("MH-1111", DriverType.NON_HANDICAP_DRIVER));            parkingLot.park(new VehicleDetails("MH-3333", DriverType.NON_HANDICAP_DRIVER));        } catch (ParkingLotException e) {            Assert.assertTrue(AirportSecurityImpl.status);            Assert.assertEquals(ParkingLotException.ExceptionType.PARKING_LOT_IS_FULL, e.type);        }    }    @Test    public void givenVehicle_IfParkingLotNowAvailable_ShouldReturnFalse() throws ParkingLotException {        try {            parkingLot.park(new VehicleDetails("MH-2222", DriverType.NON_HANDICAP_DRIVER));            parkingLot.park(new VehicleDetails("MH-1111", DriverType.NON_HANDICAP_DRIVER));            parkingLot.park(new VehicleDetails("MH-3333", DriverType.NON_HANDICAP_DRIVER));        } catch (ParkingLotException e) {            Assert.assertEquals(ParkingLotException.ExceptionType.PARKING_LOT_IS_FULL, e.type);            parkingLot.unPark("MH-1111");            Assert.assertFalse(ParkingOwnerImpl.status);        }    }    @Test    public void givenVehicle_IfSpaceIsAvailable_ShouldReturnParkingLotNumberNo() throws ParkingLotException {        parkingLot.park(new VehicleDetails("MH-2222", DriverType.NON_HANDICAP_DRIVER));        parkingLot.allocateLotNo(new VehicleDetails("MH-3333", DriverType.NON_HANDICAP_DRIVER));        parkingLot.park(new VehicleDetails("MH-1111", DriverType.NON_HANDICAP_DRIVER));    }    @Test    public void givenVehicle_AlreadyParkedAndWantsToAllocateLot_ShouldHandleException() {        try {            parkingLot.park(new VehicleDetails("MH-2222", DriverType.NON_HANDICAP_DRIVER));            parkingLot.allocateLotNo(new VehicleDetails("MH-3333", DriverType.NON_HANDICAP_DRIVER));        } catch (ParkingLotException e) {            Assert.assertEquals(ParkingLotException.ExceptionType.VEHICLE_ALREADY_PARKED, e.type);        }    }    @Test    public void givenVehicle_CheckVehiclePresentOrNotIfParked_ShouldReturnParkingLotNumber() {        try {            parkingLot.park(new VehicleDetails("A", DriverType.NON_HANDICAP_DRIVER));            boolean lotNo = parkingLot.isMyVehiclePresent("A");            Assert.assertTrue(lotNo);        } catch (ParkingLotException e) {            Assert.assertEquals(ParkingLotException.ExceptionType.VEHICLE_NOT_PARKED, e.type);        }    }    @Test    public void givenVehicle_CheckVehiclePresentOrNotIfNotParked_ShouldHandleException() {        try {            parkingLot.park(new VehicleDetails("MH-2222", DriverType.NON_HANDICAP_DRIVER));            parkingLot.isMyVehiclePresent("MH-2222");        } catch (ParkingLotException e) {            Assert.assertEquals(ParkingLotException.ExceptionType.VEHICLE_NOT_PARKED, e.type);        }    }    @Test    public void givenVehicleDetails_IfVehicleIsParkedAlready_ShouldReturnParkingTime() throws ParkingLotException {        parkingLot.park(new VehicleDetails("MH-2222", DriverType.NON_HANDICAP_DRIVER));        parkingLot.park(new VehicleDetails("MH-1111", DriverType.NON_HANDICAP_DRIVER));        parkingLot.vehicleArrivedTime("MH-1111");    }    @Test    public void givenVehicleDetails_IfVehicleIsNotParkedWhileCheckingForVehicleTiming_ShouldReturnHandleException() {        try {            parkingLot.park(new VehicleDetails("MH-2222", DriverType.NON_HANDICAP_DRIVER));            parkingLot.park(new VehicleDetails("MH-1111", DriverType.NON_HANDICAP_DRIVER));            LocalDateTime parkedTime = parkingLot.vehicleArrivedTime("MH-1111");            DateTimeFormatter format1 = DateTimeFormatter.ofPattern("dd-MM-yyyy HH:mm");            String parkedDateTime = parkedTime.format(format1);            LocalDateTime currentTime=LocalDateTime.now();            DateTimeFormatter format2 = DateTimeFormatter.ofPattern("dd-MM-yyyy HH:mm");            String currentDateTime = currentTime.format(format2);            Assert.assertEquals(parkedDateTime,currentDateTime);        } catch (ParkingLotException e) {            Assert.assertEquals(ParkingLotException.ExceptionType.VEHICLE_NOT_PARKED, e.type);        }    }    @Test    public void givenVehicleDetails_IfVehicleNotPresent_ShouldAllocateLotsEvenly() throws ParkingLotException {        parkingLot.allocateLotNo(new VehicleDetails("MH-11", DriverType.NON_HANDICAP_DRIVER));        parkingLot.allocateLotNo(new VehicleDetails("MH-22", DriverType.NON_HANDICAP_DRIVER));        parkingLot.allocateLotNo(new VehicleDetails("MH-33", DriverType.NON_HANDICAP_DRIVER));        parkingLot.allocateLotNo(new VehicleDetails("MH-44", DriverType.NON_HANDICAP_DRIVER));        parkingLot.allocateLotNo(new VehicleDetails("MH-55", DriverType.NON_HANDICAP_DRIVER));        parkingLot.allocateLotNo(new VehicleDetails("MH-66", DriverType.NON_HANDICAP_DRIVER));        parkingLot.allocateLotNo(new VehicleDetails("MH-67", DriverType.NON_HANDICAP_DRIVER));        boolean parkingStatus = parkingLot.isMyVehiclePresent("MH-67");        Assert.assertTrue(parkingStatus);    }    @Test    public void givenVehicleDetails_IfVehicleAlreadyParked_ShouldHandleException() {        try {            parkingLot.allocateLotNo(new VehicleDetails("MH-11", DriverType.NON_HANDICAP_DRIVER));            parkingLot.allocateLotNo(new VehicleDetails("MH-22", DriverType.NON_HANDICAP_DRIVER));            parkingLot.allocateLotNo(new VehicleDetails("MH-33", DriverType.NON_HANDICAP_DRIVER));            parkingLot.allocateLotNo(new VehicleDetails("MH-33", DriverType.NON_HANDICAP_DRIVER));        } catch (ParkingLotException e) {            Assert.assertEquals(ParkingLotException.ExceptionType.VEHICLE_ALREADY_PARKED, e.type);        }    }    @Test    public void givenVehicle_IfDriverTypeIsHandicap_ShouldParkToNearestLot() throws ParkingLotException {        parkingLot.allocateLotNo(new VehicleDetails("MH-11", DriverType.NON_HANDICAP_DRIVER));        parkingLot.allocateLotNo(new VehicleDetails("MH-22", DriverType.NON_HANDICAP_DRIVER));        parkingLot.allocateLotNo(new VehicleDetails("MH-33", DriverType.NON_HANDICAP_DRIVER));        parkingLot.allocateLotNo(new VehicleDetails("MH-44", DriverType.HANDICAP_DRIVER));        parkingLot.allocateLotNo(new VehicleDetails("MH-55", DriverType.NON_HANDICAP_DRIVER));    }}